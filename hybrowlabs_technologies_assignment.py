# -*- coding: utf-8 -*-
"""Hybrowlabs Technologies Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JwkGjPnWrOk2hVdHPfbYwvUBp6DkdN_M

**Part 1: DSA**
"""

# Problem 1: Stack
# Implement a stack data structure in Python. The stack should support the following operations:

def push(self, item):
    self.items.append(item)

def pop(self):
    if not self.is_empty():
        return self.items.pop()

def peek(self):
    if not self.is_empty():
        return self.items[-1]

def is_empty(self):
    return len(self.items) == 0

# Problem 2: Queue
# Implement a queue data structure in Python. The queue should support the following operations:
# enqueue(item) - Add an item to the back of the queue.
# dequeue() - Remove and return the item at the front of the queue.
# peek() - Return the item at the front of the queue without removing it.
# is_empty() - Return True if the queue is empty, else False.


def enqueue(self, item):
    self.items.append(item)

def dequeue(self):
    if not self.is_empty():
        return self.items.pop(0)

def peek(self):
    if not self.is_empty():
        return self.items[0]

def is_empty(self):
    return len(self.items) == 0

# Problem 3: Binary Search Tree
# Implement a binary search tree (BST) data structure in Python. The BST should support the following operations:
# insert(item) - Insert an item into the tree.
# delete(item) - Remove an item from the tree.
# search(item) - Return True if the item is in the tree, else False.
# size() - Return the number of nodes in the tree.


def insert(self, key):
    if self.root is None:
        self.root = Node(key)
    else:
        self._insert(key, self.root)

def _insert(self, key, current_node):
    if key < current_node.val:
        if current_node.left is None:
            current_node.left = Node(key)
        else:
            self._insert(key, current_node.left)
    else:
        if current_node.right is None:
            current_node.right = Node(key)
        else:
            self._insert(key, current_node.right)

def delete(self, key):
    if self.root:
        self.root = self._delete(key, self.root)

def _delete(self, key, current_node):
    if current_node is None:
        return current_node

    if key < current_node.val:
        current_node.left = self._delete(key, current_node.left)
    elif key > current_node.val:
        current_node.right = self._delete(key, current_node.right)
    else:
        if current_node.left is None:
            return current_node.right
        elif current_node.right is None:
            return current_node.left
        else:
            min_val_node = self._find_min_node(current_node.right)
            current_node.val = min_val_node.val
            current_node.right = self._delete(min_val_node.val, current_node.right)

    return current_node

def _find_min_node(self, node):
    current_node = node
    while current_node.left is not None:
        current_node = current_node.left
    return current_node

def search(self, key):
    return self._search(key, self.root)

def _search(self, key, current_node):
    if current_node is None:
        return False
    elif current_node.val == key:
        return True
    elif key < current_node.val:
        return self._search(key, current_node.left)
    else:
        return self._search(key, current_node.right)

def size(self):
    return self._size(self.root)

def _size(self, current_node):
    if current_node is None:
        return 0
    else:
        return 1 + self._size(current_node.left) + self._size(current_node.right)

"""**Part 2: Python**"""

# Problem 1: Anagram Checker
# Write a Python function that takes in two strings and returns True if they are anagrams of each other, 
# else False. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, 
# typically using all the original letters exactly once.

def is_anagram(str1, str2):
  return sorted(str1) == sorted(str2)

is_anagram("abcd","dbca")

# Problem 2: FizzBuzz
# Write a Python function that takes in an integer n and prints the numbers from 1 to n. 
# For multiples of 3, print "Fizz" instead of the number. For multiples of 5, print "Buzz" instead of the number. 
# For multiples of both 3 and 5, print "FizzBuzz" instead of the number.


def fizzbuzz(n):
    for i in range(1, n+1):
        if i % 3 == 0 and i % 5 == 0:
            print("FizzBuzz")
        elif i % 3 == 0:
            print("Fizz")
        elif i % 5 == 0:
            print("Buzz")
        else:
            print(i)

fizzbuzz(10)

# Problem 3: Fibonacci Sequence
# Write a Python function that takes in an integer n and returns the nth number in the Fibonacci sequence. 
# The Fibonacci sequence is a series of numbers in which each number after the first two is the sum of the 
# two preceding ones.

def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

fibonacci(3)